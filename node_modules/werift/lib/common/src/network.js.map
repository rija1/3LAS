{"version":3,"file":"network.js","sourceRoot":"","sources":["../../../../common/src/network.ts"],"names":[],"mappings":"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","sourcesContent":["import { createSocket, SocketType } from \"dgram\";\n\nexport type InterfaceAddresses = {\n  [K in SocketType]?: string;\n};\n\nexport const interfaceAddress = (\n  type: SocketType,\n  interfaceAddresses: InterfaceAddresses | undefined\n) => (interfaceAddresses ? interfaceAddresses[type] : undefined);\n\nexport async function randomPort(\n  protocol: SocketType = \"udp4\",\n  interfaceAddresses?: InterfaceAddresses\n) {\n  const socket = createSocket(protocol);\n\n  setImmediate(() =>\n    socket.bind({\n      port: 0,\n      address: interfaceAddress(protocol, interfaceAddresses),\n    })\n  );\n\n  await new Promise<void>((r) => {\n    socket.once(\"error\", r);\n    socket.once(\"listening\", r);\n  });\n\n  const port = socket.address()?.port;\n  await new Promise<void>((r) => socket.close(() => r()));\n  return port;\n}\n\nexport async function randomPorts(\n  num: number,\n  protocol: SocketType = \"udp4\",\n  interfaceAddresses?: InterfaceAddresses\n) {\n  return Promise.all(\n    [...Array(num)].map(() => randomPort(protocol, interfaceAddresses))\n  );\n}\n\nexport async function findPort(\n  min: number,\n  max: number,\n  protocol: SocketType = \"udp4\",\n  interfaceAddresses?: InterfaceAddresses\n) {\n  let port: number | undefined;\n\n  for (let i = min; i <= max; i++) {\n    const socket = createSocket(protocol);\n\n    setImmediate(() =>\n      socket.bind({\n        port: i,\n        address: interfaceAddress(protocol, interfaceAddresses),\n      })\n    );\n\n    const err = await new Promise<Error | void>((r) => {\n      socket.once(\"error\", (e) => r(e));\n      socket.once(\"listening\", () => r());\n    });\n    if (err) {\n      await new Promise<void>((r) => socket.close(() => r()));\n      continue;\n    }\n\n    port = socket.address()?.port;\n    await new Promise<void>((r) => socket.close(() => r()));\n    if (min <= port && port <= max) {\n      break;\n    }\n  }\n\n  if (!port) throw new Error(\"port not found\");\n\n  return port;\n}\n"]}