{"version":3,"file":"keyExchange.js","sourceRoot":"","sources":["../../../../../../../dtls/src/handshake/message/server/keyExchange.ts"],"names":[],"mappings":";;;AAAA,6CAA4C;AAG5C,+DAAuE;AAEvE,iDAAoD;AACpD,uCAA4C;AAE5C,MAAa,iBAAiB;IAe5B,YACS,iBAA6B,EAC7B,UAAgC,EAChC,eAAuB,EACvB,SAAiB,EACjB,aAAqB,EACrB,kBAA0B,EAC1B,eAAuB,EACvB,SAAiB;;;;;mBAPjB;;;;;;mBACA;;;;;;mBACA;;;;;;mBACA;;;;;;mBACA;;;;;;mBACA;;;;;;mBACA;;;;;;mBACA;;QAtBT;;;;mBAAU,qBAAa,CAAC,sBAAsB;WAAC;QAC/C;;;;;WAAoB;IAsBjB,CAAC;IAEJ,MAAM,CAAC,WAAW;QAChB,OAAO,IAAI,iBAAiB,CAC1B,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,EAChB,SAAgB,CACjB,CAAC;IACJ,CAAC;IAED,MAAM,CAAC,WAAW,CAAC,GAAW;QAC5B,MAAM,GAAG,GAAG,IAAA,oBAAM,EAAC,GAAG,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC;QAChD,OAAO,IAAI,iBAAiB;QAC1B,YAAY;QACZ,GAAG,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,CACtB,CAAC;IACJ,CAAC;IAED,SAAS;QACP,MAAM,GAAG,GAAG,IAAA,qBAAY,EAAC,IAAI,EAAE,iBAAiB,CAAC,IAAI,CAAC,CAAC;QACvD,OAAO,GAAG,CAAC;IACb,CAAC;IAED,UAAU;QACR,MAAM,IAAI,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC;QAC9B,OAAO,IAAI,8BAAmB,CAC5B,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,UAAW,EAChB,CAAC,EACD,IAAI,CAAC,MAAM,EACX,IAAI,CACL,CAAC;IACJ,CAAC;;AA9DH,8CA+DC;AA3DQ;;;;WAAgB;QACrB,iBAAiB,EAAE,mBAAK,CAAC,KAAK;QAC9B,UAAU,EAAE,mBAAK,CAAC,QAAQ;QAC1B,eAAe,EAAE,mBAAK,CAAC,KAAK;QAC5B,SAAS,EAAE,mBAAK,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,eAAe,CAAC;QAClE,aAAa,EAAE,mBAAK,CAAC,KAAK;QAC1B,kBAAkB,EAAE,mBAAK,CAAC,KAAK;QAC/B,eAAe,EAAE,mBAAK,CAAC,QAAQ;QAC/B,SAAS,EAAE,mBAAK,CAAC,MAAM,CAAC,CAAC,GAAQ,EAAE,EAAE,CAAC,GAAG,CAAC,OAAO,CAAC,eAAe,CAAC;KACnE;GAAC","sourcesContent":["import { decode, types } from \"binary-data\";\n\nimport { CurveTypes, NamedCurveAlgorithms } from \"../../../cipher/const\";\nimport { FragmentedHandshake } from \"../../../record/message/fragment\";\nimport { Handshake } from \"../../../typings/domain\";\nimport { encodeBuffer } from \"../../../util/binary\";\nimport { HandshakeType } from \"../../const\";\n\nexport class ServerKeyExchange implements Handshake {\n  msgType = HandshakeType.server_key_exchange_12;\n  messageSeq?: number;\n\n  static readonly spec = {\n    ellipticCurveType: types.uint8,\n    namedCurve: types.uint16be,\n    publicKeyLength: types.uint8,\n    publicKey: types.buffer((ctx: any) => ctx.current.publicKeyLength),\n    hashAlgorithm: types.uint8,\n    signatureAlgorithm: types.uint8,\n    signatureLength: types.uint16be,\n    signature: types.buffer((ctx: any) => ctx.current.signatureLength),\n  };\n\n  constructor(\n    public ellipticCurveType: CurveTypes,\n    public namedCurve: NamedCurveAlgorithms,\n    public publicKeyLength: number,\n    public publicKey: Buffer,\n    public hashAlgorithm: number,\n    public signatureAlgorithm: number,\n    public signatureLength: number,\n    public signature: Buffer\n  ) {}\n\n  static createEmpty() {\n    return new ServerKeyExchange(\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any,\n      undefined as any\n    );\n  }\n\n  static deSerialize(buf: Buffer) {\n    const res = decode(buf, ServerKeyExchange.spec);\n    return new ServerKeyExchange(\n      //@ts-ignore\n      ...Object.values(res)\n    );\n  }\n\n  serialize() {\n    const res = encodeBuffer(this, ServerKeyExchange.spec);\n    return res;\n  }\n\n  toFragment() {\n    const body = this.serialize();\n    return new FragmentedHandshake(\n      this.msgType,\n      body.length,\n      this.messageSeq!,\n      0,\n      body.length,\n      body\n    );\n  }\n}\n"]}