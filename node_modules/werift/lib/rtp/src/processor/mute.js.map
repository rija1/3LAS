{"version":3,"file":"mute.js","sourceRoot":"","sources":["../../../../../rtp/src/processor/mute.ts"],"names":[],"mappings":";;;AAAA,mCAAoC;AASpC,MAAa,eAAe;IAQ1B,YACU,MAA+B,EAC/B,KAKP;;;;;mBANO;;;;;;mBACA;;QATV;;;;mBAAc,IAAA,mBAAU,GAAE;WAAC;QAC3B;;;;mBAA+B,EAAE;WAAC;QAClC;;;;mBAAkB,KAAK;WAAC;QACxB;;;;mBAAgB,KAAK;WAAC;QACtB;;;;;WAAwB;QACxB;;;;;WAAkC;QA6DlC;;;;mBAAe,CAAC,EAAE,KAAK,EAAE,GAAG,EAAa,EAAgB,EAAE;gBACzD,IAAI,GAAG,EAAE;oBACP,IAAI,CAAC,IAAI,EAAE,CAAC;oBACZ,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC;iBACxB;gBAED,IAAI,KAAK,EAAE;oBACT,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBAC7B,IAAI,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,gBAAgB,EAAE;wBACvC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;qBACzB;iBACF;gBAED,OAAO,EAAE,CAAC;YACZ,CAAC;WAAC;IAjEC,CAAC;IAEJ,MAAM;QACJ,OAAO,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC;IACzB,CAAC;IAEO,WAAW,CAAC,aAAqB;QACvC,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,OAAO;SACR;QACD,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QAEpB,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC;QAC1D,IAAI,CAAC,gBAAgB,GAAG,aAAa,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,WAAW,CAAC,GAAG,EAAE;YACjC,IAAI,IAAI,CAAC,KAAK,EAAE;gBACd,OAAO;aACR;YAED,IAAI,IAAI,IAAI,IAAI,EAAE;gBAChB,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;aAC3D;YACD,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAChC,MAAM,MAAM,GAAG,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC;YAChE,IAAI,MAAM,GAAG,IAAI,CAAC,gBAAgB,GAAG,QAAQ,EAAE;gBAC7C,KACE,IAAI,IAAI,GAAG,MAAM,EACjB,IAAI,GAAG,IAAI,CAAC,gBAAgB,GAAG,QAAQ,EACvC,IAAI,IAAI,KAAK,EACb;oBACA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;wBACf,IAAI;wBACJ,IAAI,EAAE,WAAW;wBACjB,UAAU,EAAE,IAAI;qBACjB,CAAC,CAAC;iBACJ;aACF;YACD,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;YACvD,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;YAEjB,IAAI,CAAC,gBAAgB,IAAI,QAAQ,CAAC;QACpC,CAAC,EAAE,QAAQ,CAAC,CAAC;IACf,CAAC;IAEO,IAAI;QACV,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC/B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,CAAC,MAAM,GAAG,SAAgB,CAAC;IACjC,CAAC;CAiBF;AAlFD,0CAkFC","sourcesContent":["import { randomUUID } from \"crypto\";\n\nimport { CodecFrame, DepacketizerOutput } from \"./depacketizer\";\nimport { Processor } from \"./interface\";\n\nexport type MuteInput = DepacketizerOutput;\n\nexport type MuteOutput = MuteInput;\n\nexport class MuteHandlerBase implements Processor<MuteInput, MuteOutput> {\n  readonly id = randomUUID();\n  private buffer: CodecFrame[] = [];\n  private started = false;\n  private ended = false;\n  private intervalId: any;\n  private currentTimestamp!: number;\n\n  constructor(\n    private output: (o: MuteOutput) => void,\n    private props: {\n      ptime: number;\n      dummyPacket: Buffer;\n      interval: number;\n      sort?: boolean;\n    }\n  ) {}\n\n  toJSON(): Record<string, any> {\n    return { id: this.id };\n  }\n\n  private startIfNeed(baseTimestamp: number) {\n    if (this.started) {\n      return;\n    }\n    this.started = true;\n\n    const { sort, interval, ptime, dummyPacket } = this.props;\n    this.currentTimestamp = baseTimestamp;\n    this.intervalId = setInterval(() => {\n      if (this.ended) {\n        return;\n      }\n\n      if (sort ?? true) {\n        this.buffer = this.buffer.sort((a, b) => a.time - b.time);\n      }\n      const last = this.buffer.at(-1);\n      const expect = last ? last.time + ptime : this.currentTimestamp;\n      if (expect < this.currentTimestamp + interval) {\n        for (\n          let time = expect;\n          time < this.currentTimestamp + interval;\n          time += ptime\n        ) {\n          this.buffer.push({\n            time,\n            data: dummyPacket,\n            isKeyframe: true,\n          });\n        }\n      }\n      this.buffer.forEach((frame) => this.output({ frame }));\n      this.buffer = [];\n\n      this.currentTimestamp += interval;\n    }, interval);\n  }\n\n  private stop() {\n    clearInterval(this.intervalId);\n    this.ended = true;\n    this.buffer = [];\n    this.output = undefined as any;\n  }\n\n  processInput = ({ frame, eol }: MuteInput): MuteOutput[] => {\n    if (eol) {\n      this.stop();\n      return [{ eol: true }];\n    }\n\n    if (frame) {\n      this.startIfNeed(frame.time);\n      if (frame.time >= this.currentTimestamp) {\n        this.buffer.push(frame);\n      }\n    }\n\n    return [];\n  };\n}\n"]}