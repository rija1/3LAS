{"version":3,"file":"dtx.js","sourceRoot":"","sources":["../../../../../rtp/src/processor/dtx.ts"],"names":[],"mappings":";;;AAAA,mCAAoC;AASpC,MAAa,OAAO;IAIlB,YAAmB,KAAa,EAAU,WAAmB;;;;;mBAA1C;;;;;;mBAAuB;;QAH1C;;;;mBAAc,IAAA,mBAAU,GAAE;WAAC;QAC3B;;;;;WAA2B;QAC3B;;;;mBAAoB,CAAC;WAAC;IAC0C,CAAC;IAEjE,MAAM;QACJ,OAAO,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC;IACpD,CAAC;IAED,YAAY,CAAC,EAAE,KAAK,EAAE,GAAG,EAAY;QACnC,IAAI,GAAG,EAAE;YACP,IAAI,CAAC,IAAI,EAAE,CAAC;YACZ,OAAO,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,CAAC;SACxB;QAED,IAAI,KAAK,EAAE;YACT,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;gBAC3B,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;aACpB;YAED,IAAI,KAAK,CAAC,IAAI,IAAI,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,KAAK,EAAE;gBACrD,MAAM,YAAY,GAA4B,EAAE,CAAC;gBACjD,KACE,IAAI,IAAI,GAAG,IAAI,CAAC,iBAAiB,EACjC,IAAI,GAAG,KAAK,CAAC,IAAI,EACjB,IAAI,IAAI,IAAI,CAAC,KAAK,EAClB;oBACA,YAAY,CAAC,IAAI,CAAC;wBAChB,KAAK,EAAE;4BACL,IAAI;4BACJ,UAAU,EAAE,KAAK,CAAC,UAAU;4BAC5B,IAAI,EAAE,IAAI,CAAC,WAAW;yBACvB;qBACF,CAAC,CAAC;oBACH,IAAI,CAAC,SAAS,EAAE,CAAC;iBAClB;gBAED,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,OAAO,CAAC,GAAG,YAAY,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;aACrC;iBAAM;gBACL,IAAI,CAAC,iBAAiB,GAAG,KAAK,CAAC,IAAI,CAAC;gBACpC,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;aACpB;SACF;QAED,OAAO,EAAE,CAAC;IACZ,CAAC;IAEO,IAAI;QACV,IAAI,CAAC,WAAW,GAAG,SAAgB,CAAC;IACtC,CAAC;CACF;AArDD,0BAqDC","sourcesContent":["import { randomUUID } from \"crypto\";\n\nimport { CodecFrame, DepacketizerOutput } from \"./depacketizer\";\nimport { Processor } from \"./interface\";\n\nexport type DtxInput = DepacketizerOutput;\n\nexport type DtxOutput = DtxInput;\n\nexport class DtxBase implements Processor<DtxInput, DtxOutput> {\n  readonly id = randomUUID();\n  previousTimestamp?: number;\n  private fillCount = 0;\n  constructor(public ptime: number, private dummyPacket: Buffer) {}\n\n  toJSON(): Record<string, any> {\n    return { id: this.id, fillCount: this.fillCount };\n  }\n\n  processInput({ frame, eol }: DtxInput): DtxOutput[] {\n    if (eol) {\n      this.stop();\n      return [{ eol: true }];\n    }\n\n    if (frame) {\n      if (!this.previousTimestamp) {\n        this.previousTimestamp = frame.time;\n        return [{ frame }];\n      }\n\n      if (frame.time != this.previousTimestamp + this.ptime) {\n        const dummyPackets: { frame: CodecFrame }[] = [];\n        for (\n          let time = this.previousTimestamp;\n          time < frame.time;\n          time += this.ptime\n        ) {\n          dummyPackets.push({\n            frame: {\n              time,\n              isKeyframe: frame.isKeyframe,\n              data: this.dummyPacket,\n            },\n          });\n          this.fillCount++;\n        }\n\n        this.previousTimestamp = frame.time;\n        return [...dummyPackets, { frame }];\n      } else {\n        this.previousTimestamp = frame.time;\n        return [{ frame }];\n      }\n    }\n\n    return [];\n  }\n\n  private stop() {\n    this.dummyPacket = undefined as any;\n  }\n}\n"]}