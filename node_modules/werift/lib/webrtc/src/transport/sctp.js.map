{"version":3,"file":"sctp.js","sourceRoot":"","sources":["../../../../src/transport/sctp.ts"],"names":[],"mappings":"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","sourcesContent":["import debug from \"debug\";\nimport { jspack } from \"jspack\";\nimport { Event } from \"rx.mini\";\nimport * as uuid from \"uuid\";\n\nimport { SCTP, SCTP_STATE, Transport } from \"../../../sctp/src\";\nimport {\n  DATA_CHANNEL_ACK,\n  DATA_CHANNEL_OPEN,\n  DATA_CHANNEL_RELIABLE,\n  WEBRTC_BINARY,\n  WEBRTC_BINARY_EMPTY,\n  WEBRTC_DCEP,\n  WEBRTC_STRING,\n  WEBRTC_STRING_EMPTY,\n} from \"../const\";\nimport {\n  DCState,\n  RTCDataChannel,\n  RTCDataChannelParameters,\n} from \"../dataChannel\";\nimport { RTCDtlsTransport } from \"./dtls\";\n\nconst log = debug(\"werift:packages/webrtc/src/transport/sctp.ts\");\n\nexport class RTCSctpTransport {\n  dtlsTransport!: RTCDtlsTransport;\n  sctp!: SCTP;\n\n  readonly onDataChannel = new Event<[RTCDataChannel]>();\n  readonly id = uuid.v4();\n\n  mid?: string;\n  mLineIndex?: number;\n  bundled = false;\n  dataChannels: { [key: number]: RTCDataChannel } = {};\n\n  private dataChannelQueue: [RTCDataChannel, number, Buffer][] = [];\n  private dataChannelId?: number;\n  private eventDisposer: (() => void)[] = [];\n\n  constructor(public port = 5000) {}\n\n  setDtlsTransport(dtlsTransport: RTCDtlsTransport) {\n    if (this.dtlsTransport && this.dtlsTransport.id === dtlsTransport.id) {\n      return;\n    }\n\n    this.eventDisposer.forEach((dispose) => dispose());\n\n    this.dtlsTransport = dtlsTransport;\n    this.sctp = new SCTP(new BridgeDtls(this.dtlsTransport), this.port);\n\n    this.eventDisposer = [\n      ...[\n        this.sctp.onReceive.subscribe(this.datachannelReceive),\n        this.sctp.onReconfigStreams.subscribe((ids: number[]) => {\n          ids.forEach((id) => {\n            const dc = this.dataChannels[id];\n            if (!dc) return;\n            // todo fix\n            dc.setReadyState(\"closing\");\n            dc.setReadyState(\"closed\");\n            delete this.dataChannels[id];\n          });\n        }),\n        this.sctp.stateChanged.connected.subscribe(() => {\n          Object.values(this.dataChannels).forEach((channel) => {\n            if (channel.negotiated && channel.readyState !== \"open\") {\n              channel.setReadyState(\"open\");\n            }\n          });\n          this.dataChannelFlush();\n        }),\n        this.sctp.stateChanged.closed.subscribe(() => {\n          Object.values(this.dataChannels).forEach((dc) => {\n            dc.setReadyState(\"closed\");\n          });\n          this.dataChannels = {};\n        }),\n        this.dtlsTransport.onStateChange.subscribe((state) => {\n          if (state === \"closed\") {\n            this.sctp.setState(SCTP_STATE.CLOSED);\n          }\n        }),\n      ].map((e) => e.unSubscribe),\n      () => (this.sctp.onSackReceived = async () => {}),\n    ];\n\n    this.sctp.onSackReceived = async () => {\n      await this.dataChannelFlush();\n    };\n  }\n\n  private get isServer() {\n    return this.dtlsTransport.iceTransport.role !== \"controlling\";\n  }\n\n  channelByLabel(label: string) {\n    return Object.values(this.dataChannels).find((d) => d.label === label);\n  }\n\n  private datachannelReceive = async (\n    streamId: number,\n    ppId: number,\n    data: Buffer\n  ) => {\n    if (ppId === WEBRTC_DCEP && data.length > 0) {\n      log(\"DCEP\", streamId, ppId, data);\n      switch (data[0]) {\n        case DATA_CHANNEL_OPEN:\n          {\n            if (data.length < 12) {\n              log(\"DATA_CHANNEL_OPEN data.length not enough\");\n              return;\n            }\n\n            if (!Object.keys(this.dataChannels).includes(streamId.toString())) {\n              const [\n                ,\n                channelType,\n                ,\n                reliability,\n                labelLength,\n                protocolLength,\n              ] = jspack.Unpack(\"!BBHLHH\", data);\n\n              let pos = 12;\n              const label = data.slice(pos, pos + labelLength).toString(\"utf8\");\n              pos += labelLength;\n              const protocol = data\n                .slice(pos, pos + protocolLength)\n                .toString(\"utf8\");\n\n              log(\"DATA_CHANNEL_OPEN\", {\n                channelType,\n                reliability,\n                streamId,\n                label,\n                protocol,\n              });\n\n              const maxRetransmits =\n                (channelType & 0x03) === 1 ? reliability : undefined;\n              const maxPacketLifeTime =\n                (channelType & 0x03) === 2 ? reliability : undefined;\n\n              // # register channel\n              const parameters = new RTCDataChannelParameters({\n                label,\n                ordered: (channelType & 0x80) === 0,\n                maxPacketLifeTime,\n                maxRetransmits,\n                protocol,\n                id: streamId,\n              });\n              const channel = new RTCDataChannel(this, parameters, false);\n              channel.isCreatedByRemote = true;\n              this.dataChannels[streamId] = channel;\n\n              this.onDataChannel.execute(channel);\n              channel.setReadyState(\"open\");\n            } else {\n              log(\"datachannel already opened\", \"retransmit ack\");\n            }\n\n            const channel = this.dataChannels[streamId];\n            this.dataChannelQueue.push([\n              channel,\n              WEBRTC_DCEP,\n              Buffer.from(jspack.Pack(\"!B\", [DATA_CHANNEL_ACK])),\n            ]);\n            await this.dataChannelFlush();\n          }\n          break;\n        case DATA_CHANNEL_ACK:\n          log(\"DATA_CHANNEL_ACK\", streamId, ppId);\n          const channel = this.dataChannels[streamId];\n          if (!channel) {\n            throw new Error(\"channel not found\");\n          }\n          channel.setReadyState(\"open\");\n          break;\n      }\n    } else {\n      const channel = this.dataChannels[streamId];\n      if (channel) {\n        const msg = (() => {\n          switch (ppId) {\n            case WEBRTC_STRING:\n              return data.toString(\"utf8\");\n            case WEBRTC_STRING_EMPTY:\n              return \"\";\n            case WEBRTC_BINARY:\n              return data;\n            case WEBRTC_BINARY_EMPTY:\n              return Buffer.from([]);\n            default:\n              throw new Error();\n          }\n        })();\n\n        channel.message.execute(msg);\n        channel.emit(\"message\", { data: msg });\n        if (channel.onmessage) {\n          channel.onmessage({ data: msg });\n        }\n      }\n    }\n  };\n\n  dataChannelAddNegotiated(channel: RTCDataChannel) {\n    if (channel.id == undefined) {\n      throw new Error();\n    }\n    if (this.dataChannels[channel.id]) {\n      throw new Error();\n    }\n\n    this.dataChannels[channel.id] = channel;\n\n    if (this.sctp.associationState === SCTP_STATE.ESTABLISHED) {\n      channel.setReadyState(\"open\");\n    }\n  }\n\n  dataChannelOpen(channel: RTCDataChannel) {\n    if (channel.id) {\n      if (this.dataChannels[channel.id])\n        throw new Error(\n          `Data channel with ID ${channel.id} already registered`\n        );\n      this.dataChannels[channel.id] = channel;\n    }\n\n    let channelType = DATA_CHANNEL_RELIABLE;\n    const priority = 0;\n    let reliability = 0;\n\n    if (!channel.ordered) {\n      channelType = 0x80;\n    }\n    if (channel.maxRetransmits) {\n      channelType = 1;\n      reliability = channel.maxRetransmits;\n    } else if (channel.maxPacketLifeTime) {\n      channelType = 2;\n      reliability = channel.maxPacketLifeTime;\n    }\n\n    // 5.1.  DATA_CHANNEL_OPEN Message\n    const data = jspack.Pack(\"!BBHLHH\", [\n      DATA_CHANNEL_OPEN,\n      channelType,\n      priority,\n      reliability,\n      channel.label.length,\n      channel.protocol.length,\n    ]);\n    const send = Buffer.concat([\n      Buffer.from(data),\n      Buffer.from(channel.label, \"utf8\"),\n      Buffer.from(channel.protocol, \"utf8\"),\n    ]);\n    this.dataChannelQueue.push([channel, WEBRTC_DCEP, send]);\n    this.dataChannelFlush();\n  }\n\n  private async dataChannelFlush() {\n    // \"\"\"\n    // Try to flush buffered data to the SCTP layer.\n\n    // We wait until the association is established, as we need to know\n    // whether we are a client or a server to correctly assign an odd/even ID\n    // to the data channels.\n    // \"\"\"\n\n    if (this.sctp.associationState != SCTP_STATE.ESTABLISHED) return;\n    if (this.sctp.outboundQueue.length > 0) return;\n\n    while (this.dataChannelQueue.length > 0) {\n      const [channel, protocol, userData] = this.dataChannelQueue.shift()!;\n\n      let streamId = channel.id;\n      if (streamId === undefined) {\n        streamId = this.dataChannelId!;\n        while (Object.keys(this.dataChannels).includes(streamId.toString())) {\n          streamId += 2;\n        }\n        this.dataChannels[streamId] = channel;\n        channel.setId(streamId);\n      }\n\n      if (protocol === WEBRTC_DCEP) {\n        await this.sctp.send(streamId, protocol, userData, {\n          ordered: true,\n        });\n      } else {\n        const expiry = channel.maxPacketLifeTime\n          ? Date.now() + channel.maxPacketLifeTime / 1000\n          : undefined;\n\n        await this.sctp.send(streamId, protocol, userData, {\n          expiry,\n          maxRetransmits: channel.maxRetransmits,\n          ordered: channel.ordered,\n        });\n        channel.addBufferedAmount(-userData.length);\n      }\n    }\n  }\n\n  datachannelSend = (channel: RTCDataChannel, data: Buffer | string) => {\n    channel.addBufferedAmount(data.length);\n\n    this.dataChannelQueue.push(\n      typeof data === \"string\"\n        ? [channel, WEBRTC_STRING, Buffer.from(data)]\n        : [channel, WEBRTC_BINARY, data]\n    );\n\n    if (this.sctp.associationState !== SCTP_STATE.ESTABLISHED) {\n      log(\"sctp not established\", this.sctp.associationState);\n    }\n\n    this.dataChannelFlush();\n  };\n\n  static getCapabilities() {\n    return new RTCSctpCapabilities(65536);\n  }\n\n  setRemotePort(port: number) {\n    this.sctp.setRemotePort(port);\n  }\n\n  async start(remotePort: number) {\n    if (this.isServer) {\n      this.dataChannelId = 0;\n    } else {\n      this.dataChannelId = 1;\n    }\n    this.sctp.isServer = this.isServer;\n\n    await this.sctp.start(remotePort);\n  }\n\n  async stop() {\n    this.dtlsTransport.dataReceiver = () => {};\n    await this.sctp.stop();\n  }\n\n  dataChannelClose(channel: RTCDataChannel) {\n    if (!([\"closing\", \"closed\"] as DCState[]).includes(channel.readyState)) {\n      channel.setReadyState(\"closing\");\n\n      if (this.sctp.associationState === SCTP_STATE.ESTABLISHED) {\n        this.sctp.reconfigQueue.push(channel.id);\n        if (this.sctp.reconfigQueue.length === 1) {\n          this.sctp.transmitReconfigRequest();\n        }\n      } else {\n        this.dataChannelQueue = this.dataChannelQueue.filter(\n          (queueItem) => queueItem[0].id !== channel.id\n        );\n        if (channel.id) {\n          delete this.dataChannels[channel.id];\n        }\n        channel.setReadyState(\"closed\");\n      }\n    }\n  }\n}\n\nexport class RTCSctpCapabilities {\n  constructor(public maxMessageSize: number) {}\n}\n\nclass BridgeDtls implements Transport {\n  constructor(private dtls: RTCDtlsTransport) {}\n  set onData(onData: (buf: Buffer) => void) {\n    this.dtls.dataReceiver = onData;\n  }\n  readonly send = (data: Buffer) => {\n    return this.dtls.sendData(data);\n  };\n  close() {}\n}\n"]}