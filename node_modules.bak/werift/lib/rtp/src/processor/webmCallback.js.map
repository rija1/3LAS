{"version":3,"file":"webmCallback.js","sourceRoot":"","sources":["../../../../../rtp/src/processor/webmCallback.ts"],"names":[],"mappings":";;;AAAA,0CAAqD;AAErD,6CAAmD;AAEnD,iCAOgB;AAEhB,MAAa,YAAa,SAAQ,eAAQ;IAGxC,YACE,MAOG,EACH,UAAsB,EAAE;QAExB,KAAK,CACH,MAAM,EACN,CAAC,MAAM,EAAE,EAAE;YACT,IAAI,IAAI,CAAC,EAAE,EAAE;gBACX,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;aACxC;QACH,CAAC,EACD,OAAO,CACR,CAAC;QArBJ;;;;;WAAkD;QAClD;;;;mBAAgB,IAAI,kBAAY,EAAE;WAAC;QAuBnC;;;;mBAAO,CAAC,EAAwC,EAAE,EAAE;gBAClD,IAAI,CAAC,EAAE,GAAG,EAAE,CAAC;gBACb,IAAI,CAAC,KAAK,EAAE,CAAC;YACf,CAAC;WAAC;QAEF;;;;mBAAa,IAAI,CAAC,iBAAiB;WAAC;QACpC;;;;mBAAa,IAAI,CAAC,iBAAiB;WAAC;IARpC,CAAC;CASF;AAhCD,oCAgCC;AAEM,MAAM,gBAAgB,GAAG,CAAC,IAAY,EAAE,EAAE,CAAC,KAAK,EAAE,KAAiB,EAAE,EAAE;IAC5E,IAAI,KAAK,CAAC,UAAU,EAAE;QACpB,MAAM,IAAA,qBAAU,EAAC,IAAI,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;KAC1C;SAAM,IAAI,KAAK,CAAC,GAAG,EAAE;QACpB,MAAM,EAAE,eAAe,EAAE,GAAG,KAAK,CAAC,GAAG,CAAC;QACtC,MAAM,OAAO,GAAG,MAAM,IAAA,eAAI,EAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QAEvC,eAAe;QACf,MAAM,OAAO,CAAC,KAAK,CACjB,eAAe,EACf,CAAC,EACD,eAAe,CAAC,MAAM,EACtB,uBAAgB,CACjB,CAAC;QAEF,WAAW;QACX,MAAM,IAAI,GAAG,MAAM,IAAA,eAAI,EAAC,IAAI,CAAC,CAAC;QAC9B,MAAM,MAAM,GAAG,IAAA,yBAAkB,EAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC7C,MAAM,OAAO,CAAC,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,MAAM,CAAC,MAAM,EAAE,0BAAmB,CAAC,CAAC;QAEnE,MAAM,OAAO,CAAC,KAAK,EAAE,CAAC;KACvB;AACH,CAAC,CAAC;AAtBW,QAAA,gBAAgB,oBAsB3B","sourcesContent":["import { appendFile, open, stat } from \"fs/promises\";\n\nimport { PromiseQueue } from \"../../../common/src\";\nimport { SupportedCodec } from \"../container/webm\";\nimport {\n  DurationPosition,\n  replaceSegmentSize,\n  SegmentSizePosition,\n  WebmBase,\n  WebmOption,\n  WebmOutput,\n} from \"./webm\";\n\nexport class WebmCallback extends WebmBase {\n  private cb!: (input: WebmOutput) => Promise<void>;\n  private queue = new PromiseQueue();\n  constructor(\n    tracks: {\n      width?: number;\n      height?: number;\n      kind: \"audio\" | \"video\";\n      codec: SupportedCodec;\n      clockRate: number;\n      trackNumber: number;\n    }[],\n    options: WebmOption = {}\n  ) {\n    super(\n      tracks,\n      (output) => {\n        if (this.cb) {\n          this.queue.push(() => this.cb(output));\n        }\n      },\n      options\n    );\n  }\n\n  pipe = (cb: (input: WebmOutput) => Promise<void>) => {\n    this.cb = cb;\n    this.start();\n  };\n\n  inputAudio = this.processAudioInput;\n  inputVideo = this.processVideoInput;\n}\n\nexport const saveToFileSystem = (path: string) => async (value: WebmOutput) => {\n  if (value.saveToFile) {\n    await appendFile(path, value.saveToFile);\n  } else if (value.eol) {\n    const { durationElement } = value.eol;\n    const handler = await open(path, \"r+\");\n\n    // set duration\n    await handler.write(\n      durationElement,\n      0,\n      durationElement.length,\n      DurationPosition\n    );\n\n    // set size\n    const meta = await stat(path);\n    const resize = replaceSegmentSize(meta.size);\n    await handler.write(resize, 0, resize.length, SegmentSizePosition);\n\n    await handler.close();\n  }\n};\n"]}