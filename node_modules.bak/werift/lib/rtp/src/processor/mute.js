"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MuteHandlerBase = void 0;
const crypto_1 = require("crypto");
class MuteHandlerBase {
    constructor(output, props) {
        Object.defineProperty(this, "output", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: output
        });
        Object.defineProperty(this, "props", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: props
        });
        Object.defineProperty(this, "id", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (0, crypto_1.randomUUID)()
        });
        Object.defineProperty(this, "buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "started", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "ended", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "intervalId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "currentTimestamp", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "processInput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ({ frame, eol }) => {
                if (eol) {
                    this.stop();
                    return [{ eol: true }];
                }
                if (frame) {
                    this.startIfNeed(frame.time);
                    if (frame.time >= this.currentTimestamp) {
                        this.buffer.push(frame);
                    }
                }
                return [];
            }
        });
    }
    toJSON() {
        return { id: this.id };
    }
    startIfNeed(baseTimestamp) {
        if (this.started) {
            return;
        }
        this.started = true;
        const { sort, interval, ptime, dummyPacket } = this.props;
        this.currentTimestamp = baseTimestamp;
        this.intervalId = setInterval(() => {
            if (this.ended) {
                return;
            }
            if (sort ?? true) {
                this.buffer = this.buffer.sort((a, b) => a.time - b.time);
            }
            const last = this.buffer.at(-1);
            const expect = last ? last.time + ptime : this.currentTimestamp;
            if (expect < this.currentTimestamp + interval) {
                for (let time = expect; time < this.currentTimestamp + interval; time += ptime) {
                    this.buffer.push({
                        time,
                        data: dummyPacket,
                        isKeyframe: true,
                    });
                }
            }
            this.buffer.forEach((frame) => this.output({ frame }));
            this.buffer = [];
            this.currentTimestamp += interval;
        }, interval);
    }
    stop() {
        clearInterval(this.intervalId);
        this.ended = true;
        this.buffer = [];
        this.output = undefined;
    }
}
exports.MuteHandlerBase = MuteHandlerBase;
//# sourceMappingURL=mute.js.map