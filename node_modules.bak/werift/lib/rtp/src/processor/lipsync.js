"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LipsyncBase = void 0;
const src_1 = require("../../../common/src");
class LipsyncBase {
    constructor(audioOutput, videoOutput, options = {}) {
        Object.defineProperty(this, "audioOutput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: audioOutput
        });
        Object.defineProperty(this, "videoOutput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: videoOutput
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: options
        });
        Object.defineProperty(this, "bufferLength", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**ms */
        Object.defineProperty(this, "baseTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "audioBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "videoBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stopped", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**ms */
        Object.defineProperty(this, "interval", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "started", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        /**ms */
        Object.defineProperty(this, "lastCommittedTime", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "intervalId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "internalStats", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "processAudioInput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ({ frame, eol }) => {
                if (!frame) {
                    this.audioOutput({ eol });
                    this.stop();
                    this.audioOutput = undefined;
                    return;
                }
                if (this.stopped) {
                    return;
                }
                if (this.baseTime == undefined) {
                    this.baseTime = frame.time;
                }
                /**ms */
                const elapsed = frame.time - this.baseTime;
                if (elapsed < 0 || frame.time < this.lastCommittedTime) {
                    return;
                }
                const index = (0, src_1.int)(elapsed / this.interval) % this.bufferLength;
                this.audioBuffer[index].push({
                    frame,
                    kind: "audio",
                });
                this.startIfNeed();
            }
        });
        Object.defineProperty(this, "processVideoInput", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ({ frame, eol }) => {
                if (!frame) {
                    this.videoOutput({ eol });
                    this.stop();
                    this.videoOutput = undefined;
                    return;
                }
                if (this.stopped) {
                    return;
                }
                if (this.baseTime == undefined) {
                    this.baseTime = frame.time;
                }
                /**ms */
                const elapsed = frame.time - this.baseTime;
                if (elapsed < 0 || frame.time < this.lastCommittedTime) {
                    return;
                }
                const index = (0, src_1.int)(elapsed / this.interval) % this.bufferLength;
                this.videoBuffer[index].push({
                    frame,
                    kind: "video",
                });
                this.startIfNeed();
            }
        });
        this.interval = this.options.syncInterval ?? 500;
        this.bufferLength = this.options.bufferingTimes ?? 10;
        this.audioBuffer = [...new Array(this.bufferLength)].map(() => []);
        this.videoBuffer = [...new Array(this.bufferLength)].map(() => []);
    }
    toJSON() {
        return {
            audioBufferLength: this.audioBuffer.flatMap((v) => v).length,
            videoBufferLength: this.videoBuffer.flatMap((v) => v).length,
            baseTime: this.baseTime,
            lastCommittedTimeSec: this.lastCommittedTime / 1000,
            ...this.internalStats,
        };
    }
    startIfNeed() {
        // 2列目にカーソルが移ってから処理を始めることで1列目の処理を完了できる
        if ([...this.audioBuffer[1], ...this.videoBuffer[1]].length === 0) {
            return;
        }
        if (this.started) {
            return;
        }
        this.started = true;
        let index = 0;
        let currentTimestamp = this.baseTime;
        const task = () => {
            const audioBuffer = this.audioBuffer[index].sort((a, b) => a.frame.time - b.frame.time);
            if (this.options.fillDummyAudioPacket) {
                const last = audioBuffer.at(-1);
                const expect = last ? last.frame.time + 20 : currentTimestamp;
                // パケット間の損失/muteはdtxプラグインでダミーパケットを挿入する
                // interval中のパケットが途中から無いもしくはinterval中にパケットが無い場合はここでダミーパケットを挿入する
                if (expect < currentTimestamp + this.interval) {
                    for (let time = expect; time < currentTimestamp + this.interval; time += 20) {
                        audioBuffer.push({
                            frame: {
                                time,
                                data: this.options.fillDummyAudioPacket,
                                isKeyframe: true,
                            },
                            kind: "audio",
                        });
                        this.internalStats["pushDummyPacket"] = {
                            count: (this.internalStats["pushDummyPacket"]?.count ?? 0) + 1,
                            at: new Date().toISOString(),
                            time,
                        };
                    }
                }
                currentTimestamp += this.interval;
            }
            const joined = [...audioBuffer, ...this.videoBuffer[index]].filter((b) => b.frame.time >= this.lastCommittedTime);
            const sorted = joined.sort((a, b) => a.frame.time - b.frame.time);
            this.audioBuffer[index] = [];
            this.videoBuffer[index] = [];
            for (const output of sorted) {
                if (output.kind === "audio") {
                    this.audioOutput(output);
                }
                else {
                    this.videoOutput(output);
                }
                this.lastCommittedTime = output.frame.time;
            }
            index++;
            if (index === this.bufferLength) {
                index = 0;
            }
        };
        this.intervalId = setInterval(task, this.interval);
    }
    stop() {
        this.stopped = true;
        clearInterval(this.intervalId);
        this.audioBuffer = [];
        this.videoBuffer = [];
    }
}
exports.LipsyncBase = LipsyncBase;
//# sourceMappingURL=lipsync.js.map