{"version":3,"file":"packet.js","sourceRoot":"","sources":["../../../../../../rtp/src/rtp/red/packet.ts"],"names":[],"mappings":"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","sourcesContent":["// rfc2198\n\nimport { debug } from \"debug\";\n\nimport { BitStream } from \"../../../../common/src\";\n\nconst log = debug(\"packages/rtp/src/rtp/red/packet.ts\");\n\n// 0                   1                    2                   3\n// 0 1 2 3 4 5 6 7 8 9 0 1 2 3  4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n// |F|   block PT  |  timestamp offset         |   block length    |\n// +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n// 0 1 2 3 4 5 6 7\n// +-+-+-+-+-+-+-+-+\n// |0|   Block PT  |\n// +-+-+-+-+-+-+-+-+\n\nexport class Red {\n  header!: RedHeader;\n  blocks: {\n    block: Buffer;\n    blockPT: number;\n    /**14bit */\n    timestampOffset?: number;\n  }[] = [];\n\n  static deSerialize(bufferOrArrayBuffer: Buffer | ArrayBuffer) {\n    const buf =\n      bufferOrArrayBuffer instanceof ArrayBuffer\n        ? Buffer.from(bufferOrArrayBuffer)\n        : bufferOrArrayBuffer;\n\n    const red = new Red();\n    let offset = 0;\n    [red.header, offset] = RedHeader.deSerialize(buf);\n\n    red.header.fields.forEach(({ blockLength, timestampOffset, blockPT }) => {\n      if (blockLength && timestampOffset) {\n        const block = buf.subarray(offset, offset + blockLength);\n        red.blocks.push({ block, blockPT, timestampOffset });\n        offset += blockLength;\n      } else {\n        const block = buf.subarray(offset);\n        red.blocks.push({ block, blockPT });\n      }\n    });\n\n    return red;\n  }\n\n  serialize() {\n    this.header = new RedHeader();\n\n    for (const { timestampOffset, blockPT, block } of this.blocks) {\n      if (timestampOffset) {\n        this.header.fields.push({\n          fBit: 1,\n          blockPT,\n          blockLength: block.length,\n          timestampOffset,\n        });\n      } else {\n        this.header.fields.push({ fBit: 0, blockPT });\n      }\n    }\n\n    let buf = this.header.serialize();\n    for (const { block } of this.blocks) {\n      buf = Buffer.concat([buf, block]);\n    }\n\n    return buf;\n  }\n}\n\nexport class RedHeader {\n  fields: RedHeaderField[] = [];\n\n  static deSerialize(buf: Buffer) {\n    let offset = 0;\n    const header = new RedHeader();\n\n    for (;;) {\n      const field: RedHeaderField = {} as any;\n      header.fields.push(field);\n\n      const bitStream = new BitStream(buf.subarray(offset));\n      field.fBit = bitStream.readBits(1);\n      field.blockPT = bitStream.readBits(7);\n\n      offset++;\n\n      if (field.fBit === 0) {\n        break;\n      }\n\n      field.timestampOffset = bitStream.readBits(14);\n      field.blockLength = bitStream.readBits(10);\n\n      offset += 3;\n    }\n\n    return [header, offset] as const;\n  }\n\n  serialize() {\n    let buf = Buffer.alloc(0);\n    for (const field of this.fields) {\n      try {\n        if (field.timestampOffset && field.blockLength) {\n          const bitStream = new BitStream(Buffer.alloc(4))\n            .writeBits(1, field.fBit)\n            .writeBits(7, field.blockPT)\n            .writeBits(14, field.timestampOffset)\n            .writeBits(10, field.blockLength);\n          buf = Buffer.concat([buf, bitStream.uint8Array]);\n        } else {\n          const bitStream = new BitStream(Buffer.alloc(1))\n            .writeBits(1, 0)\n            .writeBits(7, field.blockPT);\n          buf = Buffer.concat([buf, bitStream.uint8Array]);\n        }\n      } catch (error: any) {\n        log(error?.message);\n        continue;\n      }\n    }\n    return buf;\n  }\n}\n\ninterface RedHeaderField {\n  /**ヘッダーの最初のビットは、別のヘッダーブロックが続くかどうかを示す。 1の場合は、さらにヘッダーブロックが続き、0の場合は、これが最後のヘッダーブロックとなります。 */\n  fBit: number;\n  blockPT: number;\n  /**14bit */\n  timestampOffset?: number;\n  /**10bit */\n  blockLength?: number;\n}\n"]}