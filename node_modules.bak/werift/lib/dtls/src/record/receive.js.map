{"version":3,"file":"receive.js","sourceRoot":"","sources":["../../../../../dtls/src/record/receive.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAI1B,sDAAmD;AACnD,mCAAiD;AACjD,iDAAyD;AACzD,mDAAoD;AAEpD,MAAM,GAAG,GAAG,IAAA,eAAK,EAAC,qDAAqD,CAAC,CAAC;AACzE,MAAM,GAAG,GAAG,IAAA,eAAK,EAAC,qDAAqD,CAAC,CAAC;AAElE,MAAM,WAAW,GAAG,CAAC,IAAY,EAAE,EAAE;IAC1C,IAAI,KAAK,GAAG,CAAC,CAAC;IACd,MAAM,OAAO,GAAoB,EAAE,CAAC;IACpC,OAAO,IAAI,CAAC,MAAM,GAAG,KAAK,EAAE;QAC1B,MAAM,cAAc,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,GAAG,EAAE,CAAC,CAAC;QACrD,IAAI,IAAI,CAAC,MAAM,GAAG,KAAK,GAAG,CAAC,EAAE,GAAG,cAAc,CAAC;YAAE,MAAM;QACvD,MAAM,MAAM,GAAG,yBAAa,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;QAC5D,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAErB,KAAK,IAAI,EAAE,GAAG,cAAc,CAAC;KAC9B;IAED,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAbW,QAAA,WAAW,eAatB;AAEK,MAAM,cAAc,GACzB,CAAC,IAAiB,EAAE,MAAqB,EAAE,EAAE,CAAC,CAAC,KAAoB,EAAE,EAAE;IACrE,MAAM,WAAW,GAAG,KAAK,CAAC,iBAAiB,CAAC,WAAW,CAAC;IAExD,QAAQ,WAAW,EAAE;QACnB,KAAK,mBAAW,CAAC,gBAAgB,CAAC,CAAC;YACjC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,oBAAoB,CAAC,CAAC;YAC1C,OAAO;gBACL,IAAI,EAAE,mBAAW,CAAC,gBAAgB;gBAClC,IAAI,EAAE,SAAS;aAChB,CAAC;SACH;QACD,KAAK,mBAAW,CAAC,SAAS,CAAC,CAAC;YAC1B,IAAI,GAAG,GAAG,KAAK,CAAC,QAAQ,CAAC;YACzB,IAAI;gBACF,IAAI,KAAK,CAAC,iBAAiB,CAAC,KAAK,GAAG,CAAC,EAAE;oBACrC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC;oBACzC,GAAG,GAAG,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;iBACnC;aACF;YAAC,OAAO,KAAK,EAAE;gBACd,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,gBAAgB,EAAE,KAAK,CAAC,CAAC;gBAC7C,MAAM,KAAK,CAAC;aACb;YACD,IAAI;gBACF,OAAO;oBACL,IAAI,EAAE,mBAAW,CAAC,SAAS;oBAC3B,IAAI,EAAE,8BAAmB,CAAC,WAAW,CAAC,GAAG,CAAC;iBAC3C,CAAC;aACH;YAAC,OAAO,KAAK,EAAE;gBACd,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,qBAAqB,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;gBACvD,MAAM,KAAK,CAAC;aACb;SACF;QACD,KAAK,mBAAW,CAAC,eAAe,CAAC,CAAC;YAChC,OAAO;gBACL,IAAI,EAAE,mBAAW,CAAC,eAAe;gBACjC,IAAI,EAAE,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC;aAClC,CAAC;SACH;QACD,KAAK,mBAAW,CAAC,KAAK,CAAC,CAAC;YACtB,IAAI,KAAK,GAAG,aAAK,CAAC,WAAW,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;YAE9C,qDAAqD;YACrD,IAAI,iBAAS,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,SAAS,EAAE;gBAC7C,MAAM,GAAG,GAAG,MAAM,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC;gBACxC,KAAK,GAAG,aAAK,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;aAChC;YACD,GAAG,CACD,IAAI,CAAC,SAAS,EACd,mBAAmB,EACnB,KAAK,EACL,iBAAS,CAAC,KAAK,CAAC,WAAW,CAAC,EAC5B,QAAQ,EACR,IAAI,CAAC,MAAM,EACX,YAAY,EACZ,IAAI,CAAC,UAAU,CAChB,CAAC;YACF,IAAI,KAAK,CAAC,KAAK,GAAG,CAAC,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;aACtC;SACF;QACD,0CAA0C;QAC1C,OAAO,CAAC,CAAC;YACP,OAAO,EAAE,IAAI,EAAE,mBAAW,CAAC,KAAK,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;SACrD;KACF;AACH,CAAC,CAAC;AAlES,QAAA,cAAc,kBAkEvB","sourcesContent":["import debug from \"debug\";\n\nimport { CipherContext } from \"../context/cipher\";\nimport { DtlsContext } from \"../context/dtls\";\nimport { Alert } from \"../handshake/message/alert\";\nimport { AlertDesc, ContentType } from \"./const\";\nimport { FragmentedHandshake } from \"./message/fragment\";\nimport { DtlsPlaintext } from \"./message/plaintext\";\n\nconst log = debug(\"werift-dtls : packages/dtls/record/receive.ts : log\");\nconst err = debug(\"werift-dtls : packages/dtls/record/receive.ts : err\");\n\nexport const parsePacket = (data: Buffer) => {\n  let start = 0;\n  const packets: DtlsPlaintext[] = [];\n  while (data.length > start) {\n    const fragmentLength = data.readUInt16BE(start + 11);\n    if (data.length < start + (12 + fragmentLength)) break;\n    const packet = DtlsPlaintext.deSerialize(data.slice(start));\n    packets.push(packet);\n\n    start += 13 + fragmentLength;\n  }\n\n  return packets;\n};\n\nexport const parsePlainText =\n  (dtls: DtlsContext, cipher: CipherContext) => (plain: DtlsPlaintext) => {\n    const contentType = plain.recordLayerHeader.contentType;\n\n    switch (contentType) {\n      case ContentType.changeCipherSpec: {\n        log(dtls.sessionId, \"change cipher spec\");\n        return {\n          type: ContentType.changeCipherSpec,\n          data: undefined,\n        };\n      }\n      case ContentType.handshake: {\n        let raw = plain.fragment;\n        try {\n          if (plain.recordLayerHeader.epoch > 0) {\n            log(dtls.sessionId, \"decrypt handshake\");\n            raw = cipher.decryptPacket(plain);\n          }\n        } catch (error) {\n          err(dtls.sessionId, \"decrypt failed\", error);\n          throw error;\n        }\n        try {\n          return {\n            type: ContentType.handshake,\n            data: FragmentedHandshake.deSerialize(raw),\n          };\n        } catch (error) {\n          err(dtls.sessionId, \"decSerialize failed\", error, raw);\n          throw error;\n        }\n      }\n      case ContentType.applicationData: {\n        return {\n          type: ContentType.applicationData,\n          data: cipher.decryptPacket(plain),\n        };\n      }\n      case ContentType.alert: {\n        let alert = Alert.deSerialize(plain.fragment);\n\n        // TODO impl more better about handle encrypted alert\n        if (AlertDesc[alert.description] == undefined) {\n          const dec = cipher.decryptPacket(plain);\n          alert = Alert.deSerialize(dec);\n        }\n        err(\n          dtls.sessionId,\n          \"ContentType.alert\",\n          alert,\n          AlertDesc[alert.description],\n          \"flight\",\n          dtls.flight,\n          \"lastFlight\",\n          dtls.lastFlight\n        );\n        if (alert.level > 1) {\n          throw new Error(\"alert fatal error\");\n        }\n      }\n      // eslint-disable-next-line no-fallthrough\n      default: {\n        return { type: ContentType.alert, data: undefined };\n      }\n    }\n  };\n"]}