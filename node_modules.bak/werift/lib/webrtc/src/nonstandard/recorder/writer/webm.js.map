{"version":3,"file":"webm.js","sourceRoot":"","sources":["../../../../../../src/nonstandard/recorder/writer/webm.ts"],"names":[],"mappings":"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","sourcesContent":["import { unlink } from \"fs/promises\";\nimport { EventDisposer } from \"rx.mini\";\n\nimport { SupportedCodec } from \"../../../../../rtp/src/container/webm\";\nimport {\n  DepacketizeCallback,\n  JitterBufferCallback,\n  LipsyncCallback,\n  MediaStreamTrack,\n  NtpTimeCallback,\n  RtcpSourceCallback,\n  RtpSourceCallback,\n  saveToFileSystem,\n  WebmCallback,\n  WeriftError,\n} from \"../../..\";\nimport { MediaWriter } from \".\";\n\nconst sourcePath = \"packages/webrtc/src/nonstandard/recorder/writer/webm.ts\";\n\nexport class WebmFactory extends MediaWriter {\n  rtpSources: RtpSourceCallback[] = [];\n\n  unSubscribers = new EventDisposer();\n\n  async start(tracks: MediaStreamTrack[]) {\n    await unlink(this.path).catch((e) => e);\n\n    const inputTracks = tracks.map((track, i) => {\n      const trackNumber = i + 1;\n      const payloadType = track.codec!.payloadType;\n\n      if (track.kind === \"video\") {\n        const codec = ((): SupportedCodec => {\n          switch (track.codec?.name.toLowerCase() as SupportedVideoCodec) {\n            case \"vp8\":\n              return \"VP8\";\n            case \"vp9\":\n              return \"VP9\";\n            case \"h264\":\n              return \"MPEG4/ISO/AVC\";\n            case \"av1x\":\n              return \"AV1\";\n            default:\n              throw new WeriftError({\n                message: \"unsupported codec\",\n                payload: { track, path: sourcePath },\n              });\n          }\n        })();\n        return {\n          kind: \"video\" as const,\n          codec,\n          clockRate: 90000,\n          trackNumber,\n          width: this.options.width,\n          height: this.options.height,\n          payloadType,\n          track,\n        };\n      } else {\n        return {\n          kind: \"audio\" as const,\n          codec: \"OPUS\" as const,\n          clockRate: 48000,\n          trackNumber,\n          payloadType,\n          track,\n        };\n      }\n    });\n\n    const webm = new WebmCallback(inputTracks, {\n      duration: this.options.defaultDuration ?? 1000 * 60 * 60 * 24,\n    });\n    const lipsync = new LipsyncCallback();\n\n    this.rtpSources = inputTracks.map(({ track, clockRate, codec }) => {\n      const rtpSource = new RtpSourceCallback();\n      const rtcpSource = new RtcpSourceCallback();\n      track.onReceiveRtp\n        .subscribe((rtp) => {\n          rtpSource.input(rtp.clone());\n        })\n        .disposer(this.unSubscribers);\n      track.onReceiveRtcp\n        .subscribe((rtcp) => {\n          rtcpSource.input(rtcp);\n        })\n        .disposer(this.unSubscribers);\n      const ntpTime = new NtpTimeCallback(clockRate);\n\n      if (track.kind === \"video\") {\n        const depacketizer = new DepacketizeCallback(codec, {\n          isFinalPacketInSequence: (h) => h.marker,\n        });\n        const jitterBuffer = new JitterBufferCallback(clockRate);\n\n        rtpSource.pipe(jitterBuffer.input);\n        rtcpSource.pipe(ntpTime.input);\n\n        jitterBuffer.pipe(ntpTime.input);\n        ntpTime.pipe(depacketizer.input);\n        depacketizer.pipe(lipsync.inputVideo);\n        lipsync.pipeVideo(webm.inputVideo);\n      } else {\n        const depacketizer = new DepacketizeCallback(codec);\n\n        rtpSource.pipe(ntpTime.input);\n        rtcpSource.pipe(ntpTime.input);\n\n        ntpTime.pipe(depacketizer.input);\n        depacketizer.pipe(lipsync.inputAudio);\n        lipsync.pipeAudio(webm.inputAudio);\n      }\n\n      return rtpSource;\n    });\n    webm.pipe(saveToFileSystem(this.path));\n  }\n\n  async stop() {\n    await Promise.all(this.rtpSources.map((r) => r.stop()));\n    this.unSubscribers.dispose();\n  }\n}\n\nconst supportedVideoCodecs = [\"h264\", \"vp8\", \"vp9\", \"av1x\"] as const;\ntype SupportedVideoCodec = typeof supportedVideoCodecs[number];\n"]}